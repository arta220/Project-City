Министерство образования и науки РФ

Федеральное государственное бюджетное образовательное учреждение высшего
образования

\"Тверской государственный технический университет\"

(ФГБОУ ВО \"ТвГТУ\")

Кафедра \"Программное обеспечение\"

Дисциплина: \"Объектно-ориентированное программирование\"

Отчёт по лабораторной работе №3

Система «Город»

Выполнил: студент 2-го курса

Смирнов М. А.

группы Б.ПИН.РИС-24.06

Проверил:

Созонтов М. К.

Тверь 2025

**ОГЛАВЛЕНИЕ** {#оглавление .TOC-Heading}
==============

[ВВЕДЕНИЕ 4](#введение)

[СИСТЕМА ЖКХ 6](#система-жкх)

[1.0. Предметная область (ЖКХ) 6](#предметная-область-жкх)

[1.1. Общая архитектура и концепция 6](#общая-архитектура-и-концепция)

[1.2. Реализованные объекты и их взаимодействие
6](#реализованные-объекты-и-их-взаимодействие)

[1.3. Визуальная индикация и взаимодействие с пользователем
9](#визуальная-индикация-и-взаимодействие-с-пользователем)

[1.4. Сбор статистики и визуализация
10](#сбор-статистики-и-визуализация)

[ПРИНЦИПЫ ООП, ИСПОЛЬЗУЕМЫЕ В СИСТЕМЕ ЖКХ
11](#принципы-ооп-используемые-в-системе-жкх)

[1.1. Инкапсуляция 11](#инкапсуляция)

[1.2. Композиция 12](#композиция)

[1.3. Слабая связанность и зависимость от абстракций
12](#слабая-связанность-и-зависимость-от-абстракций)

[1.4. Наследование и полиморфизм 13](#наследование-и-полиморфизм)

[1.5. Единственная ответственность (Single Responsibility Principle)
14](#единственная-ответственность-single-responsibility-principle)

[АЛГОРИТМЫ РАБОТЫ СИСТЕМЫ 15](#алгоритмы-работы-системы)

[1.1. Алгоритм симуляции поломок 15](#алгоритм-симуляции-поломок)

[1.2. Алгоритм устранения неисправностей
15](#алгоритм-устранения-неисправностей)

[1.3. Алгоритм сбора и визуализации статистики
16](#алгоритм-сбора-и-визуализации-статистики)

[ТЕСТИРОВАНИЕ 17](#тестирование)

[1.1. Стратегия тестирования 17](#_Toc215251564)

[1.2. Тестирование базовых компонентов
17](#тестирование-базовых-компонентов)

[1.3. Тестирование интеграции с системой зданий
18](#тестирование-интеграции-с-системой-зданий)

[1.4. Интеграционное и сценарное тестирование
19](#интеграционное-и-сценарное-тестирование)

[1.5. Результаты тестирования и покрытие
19](#результаты-тестирования-и-покрытие)

[СИСТЕМА ПЕШЕХОДНОЙ ИНФРАСТРУКТУРЫ
20](#система-пешеходной-инфраструктуры)

[1.0. Предметная область (Пешеходная инфраструктура)
20](#предметная-область-пешеходная-инфраструктура)

[1.1. Общая архитектура и концепция
20](#общая-архитектура-и-концепция-1)

[1.2. Парки: разнообразие и реализация
20](#парки-разнообразие-и-реализация)

[1.3. Дорожки: строительство и визуализация
22](#дорожки-строительство-и-визуализация)

[ТЕСТИРОВАНИЕ СИСТЕМЫ ПЕШЕХОДНОЙ ИНФРАСТРУКТУРЫ
26](#тестирование-системы-пешеходной-инфраструктуры)

[1.1. Стратегия тестирования 26](#стратегия-тестирования)

[1.2. Тестирование базовых перечислений
26](#тестирование-базовых-перечислений)

[1.3. Тестирование фабрик создания объектов
26](#тестирование-фабрик-создания-объектов)

[1.4. Тестирование бизнес-логики 27](#тестирование-бизнес-логики)

[1.5. Тестирование интеграции с системой размещения
28](#тестирование-интеграции-с-системой-размещения)

[1.6. Результаты тестирования и покрытие
29](#результаты-тестирования-и-покрытие-1)

[ЗАКЛЮЧЕНИЕ 30](#заключение)

ВВЕДЕНИЕ
========

Современные градостроительные симуляторы представляют собой сложные
программные комплексы, требующие интеграции множества взаимосвязанных
систем.

В рамках данного группового проекта моей задачей была разработка двух
важнейших компонентов городской инфраструктуры: системы управления
коммунальными услугами (ЖКХ) и пешеходной инфраструктуры.

**Актуальность** создания системы ЖКХ обусловлена необходимостью
создания сбалансированной игровой механики, где случайные события (такие
как поломки коммунальных систем) вносят элемент непредсказуемости и
требуют от игрока оперативного реагирования.

Второй моей задачей была разработка пешеходной инфраструктуры города.
Этот модуль отвечает за создание и управление объектами, повышающими
качество жизни граждан: парками различных типов, а также сетью
пешеходных и велосипедных дорожек. **Актуальность** этой подсистемы
заключается в необходимости предоставить игроку инструменты для
планирования комфортной городской среды.

**Целью работы** являлась разработка двух ключевых систем городского
симулятора: системы управления коммунальными услугами (ЖКХ) и системы
пешеходной инфраструктуры.

**Для достижения этой цели были поставлены следующие задачи:**

1.  Разработать систему имитации поломок и починок коммунальных услуг
    (электричество, вода, газ, вывоз отходов) с настраиваемой
    вероятностью возникновения.

2.  Реализовать механизмы визуальной индикации неисправностей и
    интуитивно понятного интерфейса для их устранения игроком.

3.  Создать комплексную систему сбора и визуализации статистики по
    работе коммунальных служб для анализа игроком.

4.  Спроектировать и реализовать разнообразные типы парковых зон (сквер,
    городской парк, ботанический сад, детская площадка, зона отдыха) с
    различными характеристиками.

5.  Разработать систему строительства пешеходных и велосипедных дорожек,
    включая визуальный предпросмотр траектории пути.

6.  Обеспечить интеграцию созданных систем с основным игровым циклом и
    UI.

**Основные принципы реализации** системы основаны на концепциях
объектно-ориентированного программирования и паттерне
Model-View-ViewModel (MVVM).

В последующих разделах отчета детально рассматриваются архитектурные
решения, ключевые классы и алгоритмы работы системы, а также приводится
анализ соответствия реализованной системы принципам
объектно-ориентированного программирования.

СИСТЕМА ЖКХ
===========

### 1.0. Предметная область (ЖКХ) {#предметная-область-жкх}

- **UtilityType** — перечисление коммунальных услуг города: Electricity, Water, Gas, Waste.
- **UtilityManager** — компонент здания, хранящий состояния услуг, признак `HasBrokenUtilities`, операции `BreakUtility`/`FixUtility`.
- **ResidentialBuilding** — жилой дом, содержащий `UtilityManager` и интегрированный в реестр размещения.
- **UtilityService** — городской сервис поломок/ремонтов: случайные поломки (5%), хранение `_brokenUtilities`, статистика (`UtilityStatistics`, `UtilityDataPoint`), метод `BreakUtilityForTesting` для сценариев.
- **UtilityWorkerScenario** — сценарий профессии UtilityWorker: в рабочее время идёт в офис, затем к дому с поломкой, выполняет задачи `MoveToBuildingTask` и `RepairBuildingTask`.
- **Статистика и графики** — накопление истории поломок/ремонтов по типам услуг и визуализация через `UtilitiesGraphProvider` (OxyPlot).

### 1.1. Общая архитектура и концепция

Разработанная система ЖКХ представляет собой комплекс взаимосвязанных
компонентов, которые имитируют работу коммунальных услуг в жилых зданиях
города. Основная концепция системы строится на том, что каждый жилой дом
зависит от четырех ключевых коммунальных услуг: электроснабжения,
водоснабжения, газоснабжения и вывоза отходов. В любой момент времени
эти услуги могут выходить из строя, создавая аварийные ситуации, которые
игрок должен оперативно устранять.

Архитектура системы была спроектирована с учетом принципов модульности и
слабой связанности. Это означает, что каждый компонент системы отвечает
за строго определенную функциональность и может развиваться относительно
независимо от других компонентов.

### 1.2. Реализованные объекты и их взаимодействие

**UtilityType (Перечисление)**

Данное перечисление служит фундаментом всей системы, определяя типы
коммунальных услуг, доступных в игре:

public enum UtilityType

{

Electricity, *// Электричество*

Water, *// Вода*

Gas, *// Газ*

Waste *// Отходы*

}

Каждое значение перечисления соответствует конкретному типу коммунальной
услуги, что обеспечивает типобезопасность и удобство работы с системой.

**UtilityManager (Класс состояния коммунальных систем)**

Этот класс является сердцем системы управления коммунальными услугами на
уровне отдельного здания. Каждый жилой дом содержит собственный
экземпляр UtilityManager, который отслеживает состояние всех четырех
коммунальных услуг.

Ключевые особенности реализации:

-   Состояния услуг хранятся в словаре для быстрого доступа

-   Автоматическое вычисление наличия неисправностей через свойство
    HasBrokenUtilities

-   Уведомление системы о изменениях состояния через механизм
    ObservableObject

public class UtilityManager : ObservableObject

{

private readonly Dictionary\<UtilityType, bool\> \_states;

public UtilityManager()

{

\_states = new Dictionary\<UtilityType, bool\>

{

\[UtilityType.Electricity\] = true,

\[UtilityType.Water\] = true,

\[UtilityType.Gas\] = true,

\[UtilityType.Waste\] = true

};

}

public bool HasBrokenUtilities =\> \_states.Values.Contains(false);

public bool IsUtilityWorking(UtilityType utilityType) =\>
\_states\[utilityType\];

}

**UtilityService (Класс симуляции городских коммунальных систем)**

Этот класс представляет основной сервис, управляющий всей системой ЖКХ в
масштабах города. В отличие от UtilityManager, который работает с
отдельным зданием, UtilityService оперирует списком всех жилых зданий и
реализует глобальную логику поломок и починок.

Основная логика симуляции поломок реализована в методе
SimulateUtilitiesBreakdown:

public void SimulateUtilitiesBreakdown(int currentTick,
List\<ResidentialBuilding\> residentialBuildings)

{

foreach (var building in residentialBuildings)

{

if (\_random.Next(100) \< 5) *// 5% шанс поломки*

{

var brokenUtility =
(UtilityType)\_random.Next(Enum.GetValues(typeof(UtilityType)).Length);

BreakUtility(building, brokenUtility, currentTick);

RecordBreakdown(brokenUtility);

UpdateStatistics(currentTick);

}

}

}

**ResidentialBuilding (Класс жилого здания с интеграцией ЖКХ)**

Интеграция системы ЖКХ в общую архитектуру проекта осуществляется через
класс ResidentialBuilding, который содержит экземпляр UtilityManager:

public class ResidentialBuilding : Building

{

public UtilityManager Utilities { get; }

public ResidentialBuilding(int floors, int maxOccupancy, Area area)

: base(floors, maxOccupancy, area)

{

Utilities = new UtilityManager();

}

}

Такая архитектура обеспечивает естественное взаимодействие системы ЖКХ с
другими компонентами игрового мира.

### 1.3. Визуальная индикация и взаимодействие с пользователем

**BlinkingColorConverter (Визуализация неисправностей)**

Для эффективного оповещения игрока о возникших неисправностях был
разработан специальный конвертер BlinkingColorConverter, который
преобразует логическое состояние \"есть неисправности\" в визуальный
эффект мигания:

public object Convert(object value, Type targetType, object parameter,
CultureInfo culture)

{

if (value is bool isBlinking && isBlinking)

{

return \_blinkState ? Brushes.Red : Brushes.DarkRed;

}

return Brushes.Gray;

}

Когда у здания возникает хотя бы одна неисправность, его цвет начинает
периодически меняться с красного на темно-красный, что создает четкий
визуальный сигнал для игрока.

**Механизм устранения неисправностей**

Процесс починки реализован через интуитивный интерфейс:

1.  Игрок кликает на мигающее здание

2.  Система запрашивает список неисправных услуг через метод
    GetBrokenUtilities

3.  Пользователь выбирает конкретную услугу для починки

4.  Вызывается метод FixUtility, который восстанавливает работу услуги

Этот механизм обеспечивает простое и понятное взаимодействие со сложной
системой коммунальных услуг.

### 1.4. Сбор статистики и визуализация

**UtilityDataPoint и UtilityStatistics (Модели данных)**

Для анализа работы системы был разработан комплекс сбора и хранения
статистики. Класс UtilityDataPoint представляет отдельную точку данных,
содержащую информацию о количестве поломок и починок на определенном
тике игрового времени. Класс UtilityStatistics агрегирует исторические
данные по всем типам коммунальных услуг.

**UtilitiesGraphProvider (Визуализация статистики)**

Наиболее сложным и информативным компонентом системы является
UtilitiesGraphProvider, который преобразует сырые статистические данные
в наглядные графики. Используя библиотеку OxyPlot, данный класс строит
комплексный график (рис. 1), отображающий динамику поломок и починок по
всем четырем типам коммунальных услуг.

![](media/image1.png){width="5.207267060367454in"
height="3.940298556430446in"}

Особенностью визуализации является одновременное отображение восьми
линий тренда - по две для каждого типа услуг (поломки и починки), что
позволяет проводить сравнительный анализ эффективности работы различных
коммунальных служб города.

ПРИНЦИПЫ ООП, ИСПОЛЬЗУЕМЫЕ В СИСТЕМЕ ЖКХ
========================================

Разработанная система ЖКХ активно использует принципы
объектно-ориентированного программирования, что обеспечивает ее
модульность, расширяемость и простоту сопровождения. Рассмотрим ключевые
принципы ООП, примененные в реализации.

### 1.1. Инкапсуляция

Принцип инкапсуляции был последовательно применен во всех компонентах
системы. Каждый класс инкапсулирует строго определенную логику и данные,
скрывая внутреннюю реализацию от внешнего кода.

**В классе UtilityManager** инкапсулирована логика управления состоянием
коммунальных услуг отдельного здания:

public class UtilityManager : ObservableObject

{

private readonly Dictionary\<UtilityType, bool\> \_states;

*// Внутреннее состояние скрыто, доступ только через методы*

public void BreakUtility(UtilityType utilityType)

{

if (\_states\[utilityType\])

{

\_states\[utilityType\] = false;

OnPropertyChanged(nameof(HasBrokenUtilities));

}

}

}

Это предотвращает непреднамеренное изменение состояния коммунальных
систем извне и обеспечивает целостность данных.

**В классе UtilityService** инкапсулирована логика симуляции поломок,
сбора статистики и управления временем поломок:

private readonly Dictionary\<ResidentialBuilding,
Dictionary\<UtilityType, int\>\> \_brokenUtilities

= new Dictionary\<ResidentialBuilding, Dictionary\<UtilityType,
int\>\>();

Внутренние структуры данных, такие как журнал поломок \_brokenUtilities,
полностью скрыты от внешнего мира, что предотвращает их некорректное
изменение.

### 1.2. Композиция

Принцип композиции демонстрирует отношение \"часть-целое\" между
объектами системы. В данном случае, жилое здание \"содержит\" менеджер
коммунальных услуг.

**В классе ResidentialBuilding** композиция реализована через включение
объекта UtilityManager:

public class ResidentialBuilding : Building

{

public UtilityManager Utilities { get; }

public ResidentialBuilding(int floors, int maxOccupancy, Area area)

: base(floors, maxOccupancy, area)

{

Utilities = new UtilityManager(); *// Композиция: UtilityManager
создается вместе с ResidentialBuilding*

}

}

Такая архитектура обеспечивает тесную связь между зданием и его
коммунальными системами - время жизни UtilityManager полностью совпадает
с временем жизни здания.

### 1.3. Слабая связанность и зависимость от абстракций

Система построена таким образом, чтобы минимизировать зависимости между
компонентами. Это достигается за счет использования интерфейсов и
абстрактных контрактов.

**Интерфейс IUtilityService** определяет контракт, который должен
реализовать основной сервис ЖКХ:

public interface IUtilityService

{

void SimulateUtilitiesBreakdown(int currentTick,
List\<ResidentialBuilding\> buildings);

void FixUtility(ResidentialBuilding building, UtilityType utilityType);

Dictionary\<UtilityType, int\> GetBrokenUtilities(ResidentialBuilding
building);

UtilityStatistics GetStatistics();

}

Это позволяет заменять реализацию UtilityService без изменения кода,
который от него зависит.

**В UtilitiesGraphProvider** используется зависимость от абстракции, а
не от конкретной реализации:

public class UtilitiesGraphProvider : IGraphDataProvider

{

private readonly IUtilityService \_utilityService; *// Зависимость от
интерфейса*

public UtilitiesGraphProvider(IUtilityService utilityService)

{

\_utilityService = utilityService; *// Внедрение зависимости через
конструктор*

}

}

Такой подход облегчает тестирование и позволяет подменять реализации для
различных сценариев.

### 1.4. Наследование и полиморфизм

Хотя в представленной системе прямое наследование используется
минимально, принцип полиморфизма применяется через реализацию
интерфейсов. Класс UtilityService реализует интерфейс IUtilityService,
что позволяет использовать его везде, где ожидается данный интерфейс.

### 1.5. Единственная ответственность (Single Responsibility Principle)

Каждый класс в системе имеет единственную причину для изменения:

-   **UtilityManager** отвечает только за состояние коммунальных услуг
    одного здания

-   **UtilityService** отвечает только за симуляцию поломок и сбор
    статистики

-   **UtilitiesGraphProvider** отвечает только за визуализацию
    статистики

-   **BlinkingColorConverter** отвечает только за преобразование
    состояния в цвет

Применение этих принципов ООП позволило создать систему, которая легко
расширяется (например, добавление нового типа коммунальной услуги
требует лишь добавления значения в перечисление UtilityType), просто
тестируется и надежно работает в составе группового проекта.

АЛГОРИТМЫ РАБОТЫ СИСТЕМЫ
========================

Работа системы ЖКХ строится на нескольких ключевых алгоритмах, которые
обеспечивают реалистичное поведение коммунальных услуг и удобное
взаимодействие с пользователем.

### 1.1. Алгоритм симуляции поломок

Процесс имитации аварийных ситуаций в коммунальных системах происходит
по следующему алгоритму:

1.  **Инициализация тика**: В начале каждого игрового тика система
    получает текущее время и список всех жилых зданий города.

2.  **Проверка вероятности поломки**: для каждого жилого здания
    выполняется проверка:

if (\_random.Next(100) \< 5) // 5% шанс поломки в каждом тике для
каждого здания

Это означает, что в среднем каждое здание испытывает поломку раз в 20
тиков.

1.  **Выбор типа неисправности**: если проверка вероятности успешна,
    случайным образом выбирается тип коммунальной услуги для поломки:
    varbrokenUtility=(UtilityType)\_random.Next(Enum.GetValues(typeof(UtilityType)).Length);

2.  **Применение поломки**: вызывается метод BreakUtility, который:

-   Обновляет состояние в UtilityManager здания

-   Записывает факт поломки в журнал с указанием тика

-   Обновляет статистику системы

3.  **Визуальное оповещение**: Система автоматически меняет визуальное
    представление здания через механизм привязки данных WPF.

### 1.2. Алгоритм устранения неисправностей

Процесс починки коммунальных услуг инициируется игроком и включает
следующие шаги:

1.  **Обнаружение проблемы**: Игрок визуально идентифицирует неисправное
    здание по мигающему красному индикатору.

2.  **Запрос информации**: при клике на здание система запрашивает
    список неисправных услуг:

public Dictionary\<UtilityType, int\>
GetBrokenUtilities(ResidentialBuilding building)

{

return \_brokenUtilities.ContainsKey(building)

? new Dictionary\<UtilityType, int\>(\_brokenUtilities\[building\])

: new Dictionary\<UtilityType, int\>();

}

1.  **Выбор действия**: Игрок выбирает конкретную услугу для починки из
    списка доступных опций.

2.  **Выполнение починки**: вызывается метод FixUtility, который:

-   Восстанавливает работу услуги через UtilityManager здания

-   Удаляет запись о поломке из внутреннего журнала

-   Обновляет статистику починок

-   Снимает визуальный индикатор неисправности

### 1.3. Алгоритм сбора и визуализации статистики

Система собирает и анализирует данные о работе коммунальных служб:

1.  **Регистрация событий**: Каждая поломка и починка регистрируется в
    соответствующих словарях статистики.

2.  **Обновление истории**: на каждом тике создаются точки данных для
    всех типов услуг.

3.  **Построение графиков**: при запросе визуализации данные
    агрегируются и преобразуются в формат, пригодный для отображения в
    библиотеке OxyPlot.

Эти алгоритмы работают согласованно, правдоподобную систему управления
коммунальным хозяйством, которая реагирует на действия игрока.

ТЕСТИРОВАНИЕ
============

Для обеспечения надежности и корректности работы системы ЖКХ был
разработан комплекс модульных тестов, охватывающих все ключевые
компоненты системы. Тестирование проводилось с использованием фреймворка
MSTest и было направлено на проверку как отдельных модулей, так и их
интеграционного взаимодействия.

Тестирование позволило убедиться в корректности работы отдельных частей
системы и проверить их совместное функционирование.

### 1.1. Тестирование базовых компонентов

**UtilityTypeTests** - проверка корректности определения перечисления
типов коммунальных услуг:

-   Проверка наличия всех четырех предопределенных типов услуг
    (Электричество, Вода, Газ, Отходы)

-   Подтверждение корректности числовых значений перечисления

-   Тестирование возможности использования UtilityType в качестве ключа
    словаря

Эти тесты обеспечивают надежную основу для работы всей системы, так как
перечисление UtilityType используется throughout всей кодовая база.

**UtilityManagerTests** - комплексная проверка логики управления
коммунальными услугами на уровне отдельного здания:

-   Проверка инициализации - все услуги должны быть исправны при
    создании

-   Тестирование механизма поломок - метод BreakUtility должен корректно
    изменять состояние услуги

-   Тестирование механизма починок - метод FixUtility должен
    восстанавливать работоспособность

-   Проверка обработки граничных случаев (повторная поломка уже
    неисправной услуги, попытка починки исправной услуги)

-   Проверка свойства HasBrokenUtilities при различных состояниях
    системы

-   Сложный сценарий с последовательными поломками и починками
    нескольких услуг

### 1.2. Тестирование интеграции с системой зданий

**ResidentialBuildingUtilityTests** - проверка интеграции UtilityManager
с жилыми зданиями:

-   Подтверждение того, что каждый экземпляр ResidentialBuilding
    содержит корректно инициализированный UtilityManager

-   Проверка начального состояния - все коммунальные услуги должны быть
    исправны при создании здания

-   Тестирование влияния поломок на состояние здания

-   Проверка восстановления работоспособности после починки

-   Эти тесты демонстрируют, что система ЖКХ органично интегрирована в
    общую архитектуру зданий и корректно взаимодействует с другими
    компонентами.

### 1.3. Интеграционное и сценарное тестирование

**UtilityIntegrationTests** - проверка сложных сценариев работы системы:

-   Тестирование независимости состояния коммунальных систем разных
    зданий - поломка в одном здании не должна влиять на другие

-   Полный сценарий \"катастрофы и восстановления\" - последовательная
    поломка всех четырех коммунальных систем с последующим их полным
    восстановлением

Интеграционные тесты особенно важны, так как они проверяют работу
системы в условиях, максимально приближенных к реальной эксплуатации.

### 1.4. Результаты тестирования и покрытие

Все разработанные тесты успешно проходят (рис. 2):

![](media/image2.png){width="3.4796522309711286in"
height="1.156411854768154in"}

*Рис. 2 -- Успешное выполнение unit-тестов системы ЖКХ*

Тестовое покрытие охватывает все критические пути выполнения системы,
включая основные сценарии использования и исключительные ситуации.

СИСТЕМА ПЕШЕХОДНОЙ ИНФРАСТРУКТУРЫ
=================================

### 1.0. Предметная область (Пешеходная инфраструктура) {#предметная-область-пешеходная-инфраструктура}

- **Парки как местность**: при размещении парка тайлы перекрашиваются в соответствующий `TerrainType` (UrbanPark, BotanicalGarden, Playground, Square, RecreationArea); при удалении исходный рельеф восстанавливается.
- **Park** — объект карты с `ParkType`, площадью `Area` и рассчитанным `TreesCount`. Используется в сценариях отдыха.
- **ParkVisitScenario** — выходной сценарий: выбирает случайный парк, ставит задачи `MoveToPositionTask` и `WalkInParkTask`, фиксирует статистику посещений.
- **WalkInParkTask** — перемещение по случайным тайлам выбранного парка с установкой состояния `RelaxingInPark`.
- **ParkVisitStatisticsService / ParkVisitsGraphProvider** — сбор по типам парков и визуализация (OxyPlot) отдельными линиями.
- **Пешеходные и велодорожки**: `PedestrianPath` и `BicyclePath` — линейные объекты 1×1 с `PathType` (Pedestrian/Bicycle), участвуют в навигации граждан.
- **PathConstructionService / IRoadConstructionService** — построение дорожек с превью на карте; блокирующие объекты препятствуют размещению.
- **CitizenProfile (navigation)** — профиль прохода: разрешает движение по незанятым тайлам, включая дорожки и парки; запрещает воду/горы и занятые объекты.

### 1.1. Общая архитектура и концепция

Разработанная система пешеходной инфраструктуры представляет собой
комплекс взаимосвязанных компонентов, которые обеспечивают создание в
виртуальном городе зон отдыха и экологичных путей сообщения.

Архитектурно система разделена на два крупных блока: **Парки** как
статические объекты и **Пути (Paths)** как линейные объекты
инфраструктуры. Оба блока построены на основе паттерна **Фабрика
(Factory)**, что обеспечивает единый механизм создания разнотипных
объектов и позволяет легко добавлять новые элементы без изменения.

Все объекты инфраструктуры наследуются от базового класса MapObject и
используют класс Area для определения занимаемой территории на игровой
карте, что обеспечивает согласованность с другими системами проекта.

### 1.2. Парки: разнообразие и реализация

Парки в системе представляют собой статические объекты, которые занимают
определенную площадь на карте и положительно влияют на привлекательность
окружающих территорий.

ParkType **(Перечисление)** служит фундаментом для классификации
парковых зон и определяет пять различных типов парков, каждый со своей
спецификой:

public enum ParkType

{

UrbanPark, *// Городской парк*

BotanicalGarden, *// Ботанический сад*

Playground, *// Детская площадка*

Square, *// Сквер*

RecreationArea *// Зона отдыха*

}

**Класс** Park инкапсулирует всю логику работы парковых зон.
Особенностью реализации является расчет количества деревьев на основе
типа и площади парка, что демонстрирует применение полиморфного
поведения через современное switch-выражение:

public class Park : MapObject

{

public ParkType Type { get; }

public int TreesCount { get; }

public Park(Area area, ParkType type) : base(area)

{

Type = type;

TreesCount = CalculateTreesCount(type, area);

}

private static int CalculateTreesCount(ParkType type, Area area)

{

return type switch

{

ParkType.BotanicalGarden =\> area.Width \* area.Height \* 5,

ParkType.Square =\> area.Width \* area.Height \* 4,

ParkType.UrbanPark =\> area.Width \* area.Height \* 3,

\_ =\> area.Width \* area.Height \* 2

};

}

}

**Фабрики парков** (такие как UrbanParkFactory,
BotanicalGardenParkFactory, PlaygroundParkFactory и другие) отвечают за
создание объектов с предопределенными параметрами. Каждая фабрика
инкапсулирует знания о том, как создать конкретный тип парка:

public class UrbanParkFactory : IMapObjectFactory

{

public MapObject Create() =\>

new Park(

area: new Area(3, 3),

type: ParkType.UrbanPark

);

}

Этот подход наглядно демонстрирует принцип единственной ответственности
- фабрика знает, как создать объект, а основной код строительства знает
только что нужно создать.

![](media/image3.png){width="6.6930555555555555in"
height="1.1548611111111111in"}

*Рис. 3 -- Панель строительства инфраструктуры*

### 1.3. Дорожки: строительство и визуализация

Пешеходные и велосипедные дорожки представляют собой линейные объекты
инфраструктуры, которые можно строить по произвольной траектории от
точки до точки.

PathType **(Перечисление)** различает типы дорожек, обеспечивая
типобезопасность при работе с системой:

public enum PathType

{

Pedestrian, *// Пешеходная дорожка*

Bicycle *// Велосипедная дорожка*

}

**Иерархия классов путей** строится вокруг базового класса Path, который
определяет общее поведение для всех типов дорожек:

public abstract class Path : MapObject

{

public PathType Type { get; }

protected Path(PathType type) : base(new Area(1, 1))

{

Type = type;

}

}

Конкретные реализации PedestrianPath и BicyclePath наследуют этот
базовый класс, устанавливая соответствующий тип дорожки. Такая
архитектура позволяет легко добавлять новые типы путей в будущем.

**Сервис** PathConstructionService является наиболее сложным компонентом
системы, реализующим интерактивное построение дорожек с визуальным
предпросмотром:

1.  **Старт строительства:** игрок выбирает тип дорожки и устанавливает
    первую точку на карте. Система запоминает начальную позицию и
    инициализирует процесс построения.

2.  **Интерактивный предпросмотр (UpdatePreview):** при перемещении
    курсора мыши система в реальном времени рассчитывает все тайлы,
    которые будут заняты дорожкой, используя алгоритм Брезенхэма для
    построения прямой линии между стартовой и текущей позицией. Все
    потенциальные тайлы подсвечиваются, давая игроку визуальную обратную
    связь.

3.  **Завершение строительства (FinishConstruction):** при клике на
    конечную точку система фиксирует путь и для каждого тайла в
    рассчитанной цепочке создает соответствующий объект дорожки
    (пешеходной или велосипедной).

Ключевой метод получения линии между точками реализован следующим
образом:

private List\<TileVM\> GetTilesAlongLine(TileVM start, TileVM end)

{

var lineTiles = new List\<TileVM\>();

*// Алгоритм Брезенхэма для построения прямой линии*

int x0 = start.X, y0 = start.Y;

int x1 = end.X, y1 = end.Y;

int dx = Math.Abs(x1 - x0);

int dy = Math.Abs(y1 - y0);

int sx = x0 \< x1 ? 1 : -1;

int sy = y0 \< y1 ? 1 : -1;

int err = dx - dy;

while (true)

{

*// Добавление текущего тайла в линию*

TileVM currentTile = \_allTiles.FirstOrDefault(t =\> t.X == x0 && t.Y ==
y0);

if (currentTile != null)

lineTiles.Add(currentTile);

if (x0 == x1 && y0 == y1) break;

*// Вычисление следующей точки линии*

int e2 = 2 \* err;

if (e2 \> -dy) { err -= dy; x0 += sx; }

if (e2 \< dx) { err += dx; y0 += sy; }

}

return lineTiles;

}

![](media/image4.png){width="2.6786362642169728in"
height="3.1351465441819775in"}![](media/image5.png){width="2.65671697287839in"
height="3.1299245406824148in"}

*Рис. 4 -- Построение дорожки с предпросмотром*

Интеграция системы в общий проект осуществляется через BuildingRegistry,
который объединяет все фабрики объектов строительства в едином
интерфейсе, обеспечивая согласованное отображение всех доступных парков
и дорожек в меню строительства игрока.

ТЕСТИРОВАНИЕ СИСТЕМЫ ПЕШЕХОДНОЙ ИНФРАСТРУКТУРЫ
==============================================

Для обеспечения надежности и корректности работы системы пешеходной
инфраструктуры был разработан комплекс тестов, охватывающих все ключевые
компоненты системы.

### 1.1. Стратегия тестирования

Тестирование системы было организовано по принципу модульного
тестирования, где каждый компонент проверялся изолированно от других.

**Основные направления тестирования:**

-   Тестирование перечислений (Enum) для проверки корректности
    определения типов

-   Тестирование фабрик для обеспечения правильного создания объектов

-   Тестирование бизнес-логики основных классов

-   Тестирование взаимодействия с системой размещения объектов на карте

### 1.2. Тестирование базовых перечислений

**ParkTypeTests** - проверка корректности определения типов парков:

-   Подтверждение наличия всех пяти предопределенных типов парков

-   Проверка корректности числовых значений перечисления

-   Тестирование полноты набора значений

**PathTypeTests** - проверка типов дорожек:

-   Подтверждение наличия обоих типов дорожек (пешеходные и
    велосипедные)

-   Проверка соответствия числовых значений

Эти тесты обеспечивают надежную основу для работы всей системы, так как
перечисления используются во всём коде в качестве ключей и
идентификаторов.

### 1.3. Тестирование фабрик создания объектов

**ParkFactoryTests** - комплексная проверка фабрик парков:

-   Тестирование каждой фабрики на создание правильного типа парка

-   Проверка корректности установки размеров для каждого типа парка

-   Подтверждение того, что фабрики создают уникальные экземпляры
    объектов

Например, тест для фабрики городского парка:

\[TestMethod\]

public void UrbanParkFactory\_CreatesCorrectPark()

{

var factory = new UrbanParkFactory();

var park = factory.Create();

Assert.IsInstanceOfType(park, typeof(Park));

Assert.AreEqual(ParkType.UrbanPark, ((Park)park).Type);

Assert.AreEqual(3, park.Area.Width);

Assert.AreEqual(3, park.Area.Height);

}

**PathFactoryTests** - проверка фабрик дорожек:

-   Тестирование создания корректных типов дорожек

-   Проверка уникальности создаваемых экземпляров

-   Подтверждение полиморфного поведения через общий интерфейс

### 1.4. Тестирование бизнес-логики

**ParkTests** - проверка логики работы парков:

-   Тестирование корректности установки свойств при создании

-   Комплексная проверка алгоритма расчета количества деревьев для всех
    типов парков

-   Подтверждение наследования от базового класса MapObject

Особое внимание уделено тестированию метода CalculateTreesCount, который
демонстрирует полиморфное поведение в зависимости от типа парка:

\[TestMethod\]

public void CalculateTreesCount\_BotanicalGarden\_ReturnsCorrectCount()

{

var area = new Area(4, 4);

var park = new Park(area, ParkType.BotanicalGarden);

Assert.AreEqual(4 \* 4 \* 5, park.TreesCount); *// 16 \* 5 = 80*

}

**PathTests** - проверка функциональности дорожек:

-   Тестирование создания пешеходных и велосипедных дорожек

-   Проверка корректности установки типа и размеров

-   Подтверждение наследования от базовых классов

### 1.5. Тестирование интеграции с системой размещения

**ParkPlacementTests** - проверка возможности размещения парков:

-   Тестирование размещения парков на допустимых типах terrain

-   Проверка корректности расчета количества деревьев в зависимости от
    типа и размера парка

**TileModelPathTests** - проверка размещения дорожек:

-   Тестирование размещения дорожек на равнинной местности

-   Проверка ограничений на размещение дорожек на воде и в горах

-   Подтверждение работы системы валидации размещения объектов

Например, тест на запрет размещения дорожек в воде:

\[TestMethod\]

public void CanPlace\_Path\_OnWater\_ReturnsFalse()

{

var tile = new TileModel { Terrain = TerrainType.Water };

var path = new PedestrianPath();

var canPlace = tile.CanPlace(path);

Assert.IsFalse(canPlace);

}

### 1.6. Результаты тестирования и покрытие

Все разработанные тесты успешно проходят, демонстрируя стабильность
работы системы. Тестовое покрытие охватывает все критические пути
выполнения, включая:

-   Создание всех типов объектов через фабрики

-   Корректность бизнес-логики расчета характеристик

-   Валидацию размещения объектов на карте

-   Обработку граничных случаев и некорректных сценариев

![](media/image6.png){width="3.55257874015748in"
height="2.8233103674540683in"}

*Рис. 5 -- Успешное выполнение unit-тестов пешеходной инфраструктуры*

Тестирование подтвердило, что система работает корректно во всех
предусмотренных сценариях использования.

.

ЗАКЛЮЧЕНИЕ
==========

В ходе выполнения работы были успешно разработаны и интегрированы в
общую архитектуру проекта две ключевые системы: комплексная модель
жилищно-коммунального хозяйства (ЖКХ) и модуль пешеходной
инфраструктуры.

Система ЖКХ внесла в геймплей элементы непредсказуемости и необходимости
быстрого принятия решений. Случайные поломки коммунальных услуг создают
дополнительные трудности для игрока, заставляя его поддерживать
работоспособность существующей инфраструктуры. Разработанные механизмы
визуальной индикации и интуитивного интерфейса починки обеспечивают
удобное взаимодействие с достаточно сложной системой управления
коммунальным хозяйством.

Разработанная система пешеходной инфраструктуры предоставила игроку
инструменты для создания гармоничной городской среды. Разнообразие типов
парков позволяет тактически подходить к планированию городских районов.

**Соответствие принципам ООП** реализованных систем было доказано на
практике. В системе ЖКХ инкапсуляция и композиция обеспечили надежную
работу логики поломок и починок, а слабая связанность компонентов
позволила легко интегрировать ее в общую архитектуру проекта. В системе
инфраструктуры наследование, полиморфизм и паттерн \"Фабрика\" позволили
создать легко расширяемую коллекцию игровых объектов, где добавление
нового типа парка или дорожки требует минимальных изменений в коде.

Таким образом, поставленные в начале работы задачи были выполнены, а
цель была достигнута.
